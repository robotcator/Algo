\documentclass[a4paper]{article}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{graphicx}
\title{\kaishu解题报告}
\author{robotcator}
\begin{document}
%\date{}
\maketitle
\begin{enumerate}

\item poj1001[高精度]
\begin{quote}
你始终要相信没有到不了的明天。
\end{quote}
\par \ \hspace{0.5cm} 最重要的是处理输入的数据，总体思想是将小数变为整数，并记
录小数的位数，最后小数的位数就是所有乘数的小数位数之和，这跟一般的小学乘法没有
区别。但是将小数变为整数时要注意去除前导和后导零，输出也要注意三点：
\begin{center}
%\begin{flushleft}
1)对于小数不要输出小数点前面的零。\newline
2)对于小数点后面的无效零不要输出。\newline
3)如果结果是整数则按整数输出。\hspace{0.75cm} \newline
%\end{flushleft}
\end{center}

\item poj2352[线段树][二叉索引树]
\begin{quote}
淡薄明志，宁静致远\hspace{5cm}
\end{quote}
\par \ \hspace{0.5cm} 因为输入点的顺序是先按y从小到大，如果y相同，再按x从小到大输入，
所以可以每插入一个x,求小于x的个数。可以用区间统计的方法解。用线段树和二叉索引树都可
以解决。
\par 线段树的建树代码:
\begin{verbatim}
void build(int root, int l, int r){
  s[root].sum = 0;
  s[root].left = l;
  s[root].right = r;
  if(r-l > 0){
    int mid = (l+r)/2;
    build(root*2, l, mid);
    build(root*2+1, mid+1, r);
  }
}
\end{verbatim}

\item poj1861[RMQ]
\par 赤裸裸的RMQ，用tarjan的sparse\_Table算法，只需要o($\log$ n)预处理时间，
o(1)就可以查询。递推式为d(i, j) = min\{ d(i, j-1) , d(i+$2^{j-1}$, j-1)\}

\item poj1850[组合数]
\begin{align*}
 C_n^k = C_{n-1}^{k} + C_{n-1}^{k-1}  
\end{align*}
\begin{align*}
    C_n^k &= C_{n-1}^{k} + C_{n-1}^{k-1}   \\
            &= C_{n-2}^{k} + C_{n-2}^{k-1} + C_{n-1}^{k-1}
\end{align*}
% algin本身就有数学环境，不需要加$$    
% \\  $\displaystyle\sum_{i=1}^{n}$


\end{enumerate}
\end{document}
